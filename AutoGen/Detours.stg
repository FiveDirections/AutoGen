//
// Generate #include statement for one or more system include files
//

include (header) ::=
<<
#include \<<header>\>
>>

api_list (apis) ::=
<<
<apis:{a|<a.func_name>}; wrap, separator = \n//					>
>>

//
// Template for the beginning of file
//

file_header(version, date, exe_name, apis_to_detour, headers, command_line) ::= 
<<
//
//	WARNING: This file was generated by AutoGen version <version> on <date>
//			 Do not make any changes to this file because they will be lost the 
//			 next time AutoGen is run
//
//	Command line: <command_line>
//

//
// FACILITY:	TraceAPI - Trace Windows APIs in <exe_name>
//
// DESCRIPTION:	This DLL is injected into a process by InjectDLL. Its purpose is to intercept the following APIs and log their 
//				parameters using the FDI-Detours TraceLogging provider ({FD06D490-ED39-4CFF-BE10-82C940BCBE74}). Diagnostic information
//				about how this program is running is output using WPP (Windows PreProcessor) ETW tracing using the GUID
//				{DCDE5106-86EE-47F2-966A-B6C425ACD9F9}
//
//				The following APIs are intercepted and logged:
//					<api_list (apis_to_detour)>
//
// VERSION:		1.1
//
// AUTHOR:		Brian Catlin
//
// CREATED:		2019-11-15
//
// MODIFICATION HISTORY:
//
//	1.1		2020-04-19	Brian Catlin
//			Support new heuristics that detect parameter data type with appropriate TraceLoggingXxx macro invocations in the trace_input_params and
//			trace_output_params string templates
//
//	1.0		2019-11-15	Brian Catlin
//			Original version
//

//
// INCLUDE FILES:
//

//
// System includes
//

#define WIN32_NO_STATUS
#include \<Windows.h>
#undef WIN32_NO_STATUS
#include \<ntstatus.h>
#include \<TraceLoggingProvider.h>
#include \<evntprov.h>

#include \<string>
#include \<list>

<if (headers)>
//
// Includes for APIs being Detoured
//

<headers:{h|<include(h)>}; separator = \n>
<endif>

//
// Project includes
//

#include detours.h

#include TraceAPI.h
#include ..\Global\Utils.h
#include ..\Global\WPP_Tracing.h
#include Version.h

#include TraceAPI.tmh								// Generated by TraceWPP

using namespace FDI;

//
// CONSTANTS:
//

//
// TYPES:
//

//
// MACROS:
//

#define ATTACH(x)       det_attach (&(PVOID&) real_##x, my_##x, #x)
#define DETACH(x)       det_detach (&(PVOID&) real_##x, my_##x, #x)

//
// DEFINITIONS:
//

//
// DECLARATIONS:
//

TRACELOGGING_DECLARE_PROVIDER (TA_tlg);

>>

//
// Generate a declaration for a pointer to the real API
//

real_api_decl (api) ::=
<<
<if (api.specifiers)>
<api.specifiers:{s|<s>}; separator = \n>
<else>
<api.ret_type>
<endif>
(WINAPI * real_<api.func_name>)
	(
	<api.parameters:{p|<p.type_qualifier> <p.type> <p.storage_class> <p.param_name>}; separator = ,\n>
	) = <api.func_name>;
>>

//
//	Generate the declaration for a Detoured routine
//

my_api_decl (api) ::=
<<
<if (api.specifiers)>
<api.specifiers:{s|<s>}; separator = \n>
<else>
<api.ret_type>
<endif>
my_<api.func_name>
	(
	<api.parameters:{p|<p.type_qualifier> <p.type> <p.storage_class> <p.param_name>}; separator = ,\n>
	);
>>

//
// Template for pointers to the real API (with a 'real_' suffix) and a forward declaration to our Detoured
// API (with a 'my_' suffix)
//

real_api_list (list) ::=
<<

//
// Pointers to the real APIs
//

extern C
{
<list:{l|<real_api_decl(l)>}; separator = \n\n>

}	// extern C

//
// FORWARD ROUTINES:
//

NTSTATUS 
attach_detours										// Intercept the APIs
	(
	);

NTSTATUS
detach_detours										// Stop intercepting the APIs
	(
	);

//
// Forward declarations of generated routines
//

<list:{l|<my_api_decl(l)>}; separator = \n\n>

>>

//
// Generate a ATTACH line for an API
//

attach (name) ::=
<<
	ATTACH (<name>);
>>

//
// Generate a DETACH line for an API
//

detach (name) ::=
<<
	DETACH (<name>);
>>

//
// Template the attach_detours and detach_detours routines
//

support_routines (exename, api_list) ::=
<<


NTSTATUS 
attach_detours										// Intercept the APIs
	(
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	//
	// Tell Detours that we're starting a transaction to update the list of detours
	//

	DetourTransactionBegin ();
	DetourUpdateThread (GetCurrentThread ());

	//
	// List all the Detours to install
	//
	// NOTE: This list MUST match the list in detach_detours
	//

<api_list:{a|<attach (a.func_name)>}; separator = \n>

	//
	// Tell Detours that we're done updating detours
	//

	status = DetourTransactionCommit ();

	TRACE_EXIT ();
	return status;
}							// End attach_detours


NTSTATUS
detach_detours										// Stop intercepting the APIs
	(
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	//
	// Tell Detours that we're starting a transaction to update the list of detours
	//

	DetourTransactionBegin ();
	DetourUpdateThread (GetCurrentThread ());

	//
	// List all the detours to remove
	//
	// NOTE: This list MUST match the list in attach_detours
	//

<api_list:{a|<detach (a.func_name)>}; separator = \n>

	//
	// Tell Detours that we're done updating detours
	//

	status = DetourTransactionCommit ();

	TRACE_EXIT ();
	return status;
}							// End detach_detours


>>

//
// This template will generate the list of detour routines that will replace Windows APIs
//

generate_routines (api_list) ::=
<<
<api_list:{a|<detour (a)>}; separator = \n\n>
>>

//
// Generate TraceLogging lines for input parameters
//

trace_input_params (parameters) ::=
<<
<parameters:{p|
<if (p.is_wstrz && !p.is_output)>
		TraceLoggingWideString (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_asciz && !p.is_output)>
		TraceLoggingString (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_output || p.is_pointer)>
		TraceLoggingPointer ((LPCVOID) <p.param_name>, <p.param_name>)<\\>
<elseif (p.is_input && p.is_scalar)>
		TraceLoggingValue (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_input && p.is_enum)>
		TraceLoggingValue ((UINT32) <p.param_name>, <p.param_name>)<\\>
<elseif (p.is_input && p.is_custom)>
		TraceLoggingBinary (&<p.param_name>, sizeof (<p.param_name>), <p.param_name>)<\\>
<endif>
}; separator = ,>
>>

//
// Generate TraceLogging lines for output parameters
//

trace_output_params (parameters) ::=
<<
<parameters:{p|<if (p.is_output)>
<if (p.is_wstrz)>
		TraceLoggingWideString (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_asciz)>
		TraceLoggingString (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_scalar && !p.is_pointer)>
		TraceLoggingValue (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_enum)>
		TraceLoggingValue ((UINT32) <p.param_name>, <p.param_name>)<\\>
<elseif (p.is_pointer && (!p.is_asciz && !p.is_wstrz && !p.is_scalar && !p.is_enum))>
		TraceLoggingPointer (<p.param_name>, <p.param_name>)<\\>
<elseif (p.is_custom)>
		TraceLoggingBinary (&<p.param_name>, sizeof (<p.param_name>), <p.param_name>)<\\>
<endif>
<endif>
}; separator = ,>
>>

//
// Template for a Detours routine. It has the same function signature as the real routine
//

detour (api) ::=
<<
<if (api.specifiers)>
<api.specifiers:{s|<s>}; separator = \n>
<else>
<api.ret_type>
<endif>
my_<api.func_name>
	(
	<api.parameters:{p|<p.type_qualifier> <p.type> <p.storage_class> <p.param_name>}; separator = ,\n>
	)

{
<if (!api.ret_void)>
NTSTATUS	status;
<api.ret_type>		ret_value;
<endif>


	//
	// Write a pre-call entry to the log with all of the parameters
	//

	TraceLoggingWrite (TA_tlg, API-Trace-PRECALL, TraceLoggingOpcode (TL_OPC_TRACE), TraceLoggingLevel (TRACE_LEVEL_INFORMATION),
		TraceLoggingKeyword (TL_KW_TRACE_PRE), 
		TraceLoggingString (<api.func_name>, API)<if (api.parameters)>,<endif>
<trace_input_params (api.parameters)>
		);

	//
	// Call the real API
	//

<if (!api.ret_void)>	ret_value = <else>	<endif>real_<api.func_name> (
				<api.parameters:{p|<p.param_name>}; wrap, anchor, separator = ,\n>);
	
	//
	// Write a post-call entry to the log with just the output parameters
	//

<if (!api.ret_void)>
	status = GetLastError ();
<endif>

	TraceLoggingWrite (TA_tlg, API-Trace-POSTCALL, TraceLoggingOpcode (TL_OPC_TRACE), TraceLoggingLevel (TRACE_LEVEL_INFORMATION),
		TraceLoggingKeyword (TL_KW_TRACE_POST), 
		TraceLoggingString (<api.func_name>, API)<\\>
<if (api.ret_pointer)><\\>
,
		TraceLoggingPointer ((PVOID) ret_value, Return value),
		TraceLoggingUInt32 (status, Last error status)<if (api.has_outputs)>,<endif>
<elseif (api.ret_scalar)><\\>
,
		TraceLoggingValue (ret_value, Return value),
		TraceLoggingUInt32 (status, Last error status)<if (api.has_outputs)>,<endif>
<elseif (api.ret_custom)><\\>
,
		TraceLoggingBinary (&ret_value, sizeof (ret_value), Return value),
		TraceLoggingUInt32 (status, Last error status)<if (api.has_outputs)>,<endif>
<elseif (api.ret_void)><\\>
<endif>
<trace_output_params (api.output_parameters)>
		);

	return<if (!api.ret_void)> ret_value;<else>;<endif>
}							// End my_<api.func_name>
