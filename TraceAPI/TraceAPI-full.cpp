//
// FACILITY:	TraceAPI - Trace specific APIs when injected into a process
//
// DESCRIPTION:	This DLL is injected into a process by InjectDLL. Its purpose is to intercept specific APIs and log their parameters using ETW
//
// VERSION:		1.0
//
// AUTHOR:		Brian Catlin
//
// CREATED:		2019-11-15
//
// MODIFICATION HISTORY:
//
//	1.0		2019-11-15	Brian Catlin
//			Original version
//

#pragma warning (disable : 4100)						// Allow unreferenced formal parameter
#pragma warning (disable : 4115)						// Allow named type definition in parentheses
#pragma warning (disable : 4127)						// Allow constant conditional expression
#pragma warning (disable : 4200)						// Allow zero-sized array in struct/union
#pragma warning (disable : 4201)						// Allow nameless struct/union
#pragma warning (disable : 4214)						// Allow bit field types other than int
#pragma warning (disable : 4514)						// Allow unreferenced inline function

//
// INCLUDE FILES:
//

//
// System includes
//

#define WIN32_NO_STATUS
#include <Windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <TraceLoggingProvider.h>
#include <evntprov.h>
#include <psapi.h>

#include <string>
#include <vector>
#include <list>
#include <memory>
#include <iterator>

//
// Project includes
//

#include "detours.h"

#include "..\Global\Utils.h"
#include "..\Global\FDI-Detours.h"
#include "..\Global\WPP_Tracing.h"
#include "Version.h"

#include "TraceAPI.tmh"								// Generated by TraceWPP

using namespace FDI;

//
// CONSTANTS:
//

//
// Define the opcodes that represent operations that are performed by the driver
// Opcodes 1-10 are reserved to Microsoft
//

enum TL_OPCODES : UCHAR
	{
	TL_OPC_UNINITIALIZED	= 0,				// Uninitialized and invalid
	TL_OPC_DLL				= 11,				// Fundamental DLL operation
	TL_OPC_TRACE,								// API trace operations
	};

//
// Define the filtering keywords that identify classes of events that can be enabled or disabled
//

enum TL_KEYWORDS : ULONGLONG
	{
	TL_KW_DLL					= 0x0000000000000001,	// Events about DLL loading and unloading
	TL_KW_TRACE_PRE				= 0x0000000000000002,	// Pre-call API traces
	TL_KW_TRACE_POST			= 0x0000000000000004,	// Post-call API traces
	};

#define TRACE_LEVEL_ALWAYS		0

//
// TYPES:
//

//
// MACROS:
//

#define	TL_PROVIDER					"FiveDirections-TraceApi"
#define TL_GUID						(0xfd06d490, 0xed39, 0x4cff, 0xbe, 0x10, 0x82, 0xc9, 0x40, 0xbc, 0xbe, 0x74)	// {FD06D490-ED39-4CFF-BE10-82C940BCBE74}

#define ATTACH(x)       div_attach (&(PVOID&) real_##x, my_##x, #x)
#define DETACH(x)       div_detach (&(PVOID&) real_##x, my_##x, #x)

#define DECLARE_UNICODE_STRING(_var, _string) \
const WCHAR _var ## _buffer[] = _string; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
UNICODE_STRING _var = { sizeof(_string) - sizeof(WCHAR), sizeof(_string), (PWCH) _var ## _buffer } \
__pragma(warning(pop))

//
// DEFINITIONS:
//

//
// DECLARATIONS:
//

const char	TA_product_description[] = VER_PRODUCTNAME_STR " " VER_INTERNALNAME_STR " v" VER_PRODUCTVERSION_STR " " VER_BUILD_TYPE_STR ", Built: " __DATE__ " " __TIME__;

TRACELOGGING_DEFINE_PROVIDER (TA_tlg, TL_PROVIDER, TL_GUID);
static LONG		TA_tls_indent = -1;
static LONG		TA_tls_thread = -1;
static LONG		TA_thread_count = 0;
WCHAR			TA_image_file_name_buff [MAX_PATH];
UNICODE_STRING	TA_image_file_name = {0};

//
// Pointers to the real APIs
//

extern "C"
{

BOOL 
(WINAPI * real_CreateProcessW)
	(
	LPCWSTR a0,
	LPWSTR a1,
	LPSECURITY_ATTRIBUTES a2,
	LPSECURITY_ATTRIBUTES a3,
	BOOL a4,
	DWORD a5,
	LPVOID a6,
	LPCWSTR a7,
	LPSTARTUPINFOW a8,
	LPPROCESS_INFORMATION a9
	) = CreateProcessW;

}	// extern "C"

//
// FORWARD ROUTINES:
//

NTSTATUS 
attach_divergences										// 
	(
	);

NTSTATUS
detach_divergences										// 
	(
	);

VOID
div_attach												// Attach the Divergences
	(
	_In_	PVOID	*Real_api,							// The real API
	_In_	PVOID	My_api,								// My Diverted API
	_In_	PCCH	Api_name							// API name
	);

VOID
div_detach												// Detach the Divergences
	(
	_In_	PVOID	*Real_api,							// The real API
	_In_	PVOID	My_api,								// My Diverted API
	_In_	PCCH	Api_name							// API name
	);

PCCH
div_real_name											// 
	(
	_In_	PCCH Name									// 
	);

BOOL 
process_attach											// Called when this DLL is loaded into a process
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	);

BOOL 
process_detach											// Called when this DLL is unloaded from a process
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	);

BOOL
thread_attach											// Called when the process creates a new thread
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	);

BOOL 
thread_detach											// Called when a thread is exiting cleanly
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	);

BOOL 
WINAPI 
my_CreateProcessW
	(
	LPCWSTR					lpApplicationName,
	LPWSTR					lpCommandLine,
	LPSECURITY_ATTRIBUTES	lpProcessAttributes,
	LPSECURITY_ATTRIBUTES	lpThreadAttributes,
	BOOL					bInheritHandles,
	DWORD					dwCreationFlags,
	LPVOID					lpEnvironment,
	LPCWSTR					lpCurrentDirectory,
	LPSTARTUPINFOW			lpStartupInfo,
	LPPROCESS_INFORMATION	lpProcessInformation
	);



BOOL 
APIENTRY 
DllMain													// Called when the DLL is loaded or unloaded from a process
	(
	_In_	HMODULE	Module_handle,						// Handle to this DLL
	_In_	DWORD	Call_reason,						// Reason for being called
	_In_	LPVOID	Reserved							// Reserved
	)

//
// DESCRIPTION:		This routine is called automatically by the image loader when this DLL is loaded
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//  TRUE						Normal, successful completion
//

{
BOOL	ret_val;


	switch (Call_reason)
		{
		case DLL_PROCESS_ATTACH:
			{
			DetourRestoreAfterWith ();

			ret_val = process_attach (Module_handle);
			}
			break;

		case DLL_PROCESS_DETACH:
			{
			ret_val = process_detach (Module_handle);
			}
			break;

		case DLL_THREAD_ATTACH:
			{
			ret_val = thread_attach (Module_handle);
			}
			break;

		case DLL_THREAD_DETACH:
			{
			ret_val = thread_detach (Module_handle);
			}
			break;

		default:
			{
			}
			break;
		}

	return TRUE;
}									// End routine DllMain


NTSTATUS 
attach_divergences										// 
	(
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	//
	// Tell Detours that we're starting a transaction to update the list of Divergences
	//

	DetourTransactionBegin ();
	DetourUpdateThread (GetCurrentThread ());

	//
	// List all the Divergences to install
	//
	// NOTE: This list MUST match the list in detach_divergences
	//

	ATTACH (CreateProcessW);

	//
	// Tell Detours that we're done updating Divergences
	//

	status = DetourTransactionCommit ();

	TRACE_EXIT ();
	return status;
}							// End attach_divergences


NTSTATUS
detach_divergences										// 
	(
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	//
	// Tell Detours that we're starting a transaction to update the list of Divergences
	//

	DetourTransactionBegin ();
	DetourUpdateThread (GetCurrentThread ());

	//
	// List all the Divergences to remove
	//
	// NOTE: This list MUST match the list in attach_divergences
	//

	DETACH (CreateProcessW);

	//
	// Tell Detours that we're done updating Divergences
	//

	status = DetourTransactionCommit ();

	TRACE_EXIT ();
	return status;
}							// End detach_divergences


VOID
div_attach												// Attach the Divergences
	(
	_In_	PVOID	*Real_api,							// The real API
	_In_	PVOID	My_api,								// My Diverted API
	_In_	PCCH	Api_name							// API name
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	//
	// Initialize the Detours library
	//

	if (ERR (status = DetourAttach (Real_api, My_api)))
		{
		TRACE_WARN (TRACEAPI, "Attach failed: `%s', status = %!STATUS!", div_real_name (Api_name), status);
		}

	TRACE_EXIT ();
	}							// End div_attach


VOID
div_detach												// Detach the Divergences
	(
	_In_	PVOID	*Real_api,							// The real API
	_In_	PVOID	My_api,								// My Diverted API
	_In_	PCCH	Api_name							// API name
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	//
	// Shutdown Detours
	//

	if (ERR (status = DetourDetach (Real_api, My_api)))
		{
		TRACE_WARN (TRACEAPI, "Detach failed: `%s', status = %!STATUS!", div_real_name (Api_name), status);
		}

	TRACE_EXIT ();
	}							// End div_detach


PCCH
div_real_name											// 
	(
	_In_	PCCH Name									// 
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
PCCH	name_ptr = Name;


	TRACE_ENTER ();

	//
	// Move to end of name.
	//

	while (*name_ptr)
		{
		name_ptr++;
		}

	//
	// Move back through A-Za-z0-9 names.
	//

	while (name_ptr > Name &&
		   ((name_ptr [-1] >= 'A' && name_ptr [-1] <= 'Z') ||
			(name_ptr [-1] >= 'a' && name_ptr [-1] <= 'z') ||
			(name_ptr [-1] >= '0' && name_ptr [-1] <= '9')))
		{
		name_ptr--;
		}

	TRACE_EXIT ();
	return name_ptr;
}							// End div_real_name


BOOL 
process_attach											// Called when this DLL is loaded into a process
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
HANDLE		process_hdl = GetCurrentProcess ();

	//
	// Initialize WPP tracing
	//

	WPP_INIT_TRACING (L"TraceAPI");
	TRACE_ALWAYS (TRACEAPI, "%s", TA_product_description);
	TRACE_ENTER ();

NTSTATUS	status;
BOOL				ret_val = TRUE;
ULONG		length;


	//
	// Get the name of the executable that loaded this DLL
	//

	if ((length = GetProcessImageFileName (process_hdl, TA_image_file_name_buff, ARRAYSIZE (TA_image_file_name_buff))) != 0)
		{

		//
		// Fill in the string descriptor
		//

		TA_image_file_name.Buffer = TA_image_file_name_buff;
		TA_image_file_name.Length = (USHORT) length * 2;
		TA_image_file_name.MaximumLength = ARRAYSIZE (TA_image_file_name_buff) * 2;
		}
	else
		{
		status = GetLastError ();
		TRACE_ERROR (TRACEAPI, "Error getting image file name, status = %!STATUS!", status);
		}

	TA_tls_indent = TlsAlloc ();
	TA_tls_thread = TlsAlloc ();

	//
	// Initialize TraceLogging
	//

	if (SUCCESS (status = TraceLoggingRegisterEx (TA_tlg, nullptr, nullptr)))
		{

		//
		// Send a message that we've been loaded
		//

		TraceLoggingWrite (TA_tlg, "DLL-Attach", TraceLoggingOpcode (TL_OPC_DLL), TraceLoggingLevel (TRACE_LEVEL_ALWAYS),
			TraceLoggingKeyword (TL_KW_DLL), TraceLoggingDescription ("DLL attached to process"),
			TraceLoggingString (TA_product_description, "DLL description"),
			TraceLoggingUnicodeString (&TA_image_file_name,  "Image file name")
			);

		//
		// Replace the pointers to the API we are tracing
		//

		if (!SUCCESS (status = attach_divergences ()))
			{
			TRACE_ERROR (TRACEAPI, "Error attaching Divergence, status = %!STATUS!", status);
			}

		thread_attach (Dll_hdl);
		}
	else
		{
		TRACE_ERROR (TRACEAPI, "Error registering with TraceLogging, status = %!STATUS!", status);
		ret_val = FALSE;
		}

	TRACE_EXIT ();
	return ret_val;
}							// End process_attach

BOOL
process_detach											// Called when this DLL is unloaded from a process
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
NTSTATUS	status;


	TRACE_ENTER ();

	TraceLoggingWrite (TA_tlg, "DLL-Detach", TraceLoggingOpcode (TL_OPC_DLL), TraceLoggingLevel (TRACE_LEVEL_ALWAYS),
		TraceLoggingKeyword (TL_KW_DLL), TraceLoggingDescription ("DLL detached from process"),
		TraceLoggingUnicodeString (&TA_image_file_name, "Image file name")
		);

	thread_detach (Dll_hdl);

	if (!SUCCESS (status = detach_divergences ()))
		{
		TRACE_ERROR (TRACEAPI, "Error detaching Divergence, status = %!STATUS!", status);
		}

	if (TA_tls_indent >= 0) 
		{
		TlsFree (TA_tls_indent);
		}

	if (TA_tls_thread >= 0) 
		{
		TlsFree (TA_tls_thread);
		}

	//
	// Disconnect from TraceLogging
	//

	TraceLoggingUnregister (TA_tlg);

	//
	// Close WPP tracing
	//

	TRACE_EXIT ();
	WPP_CLEANUP ();
	return TRUE;
}							// End process_detach


BOOL
thread_attach											// Called when the process creates a new thread
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
LONG num_thread;


	UNREFERENCED_PARAMETER (Dll_hdl);

	TRACE_ENTER ();

	if (TA_tls_indent >= 0) 
		{
		TlsSetValue (TA_tls_indent, (PVOID) 0);
		}

	if (TA_tls_thread >= 0) 
		{
		num_thread = InterlockedIncrement (&TA_thread_count);
		TlsSetValue (TA_tls_thread, (PVOID) (LONG_PTR) num_thread);
		}

	TRACE_EXIT ();
	return TRUE;
}							// End thread_attach


BOOL 
thread_detach											// Called when a thread is exiting cleanly
	(
	_In_	HMODULE		Dll_hdl							// This DLL's module handle							
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
	UNREFERENCED_PARAMETER (Dll_hdl);

	TRACE_ENTER ();

	if (TA_tls_indent >= 0)
		{
		TlsSetValue (TA_tls_indent, (PVOID) 0);
		}

	if (TA_tls_thread >= 0) 
		{
		TlsSetValue(TA_tls_thread, (PVOID) 0);
		}

	TRACE_EXIT ();
	return TRUE;
}							// End thread_detach


BOOL 
WINAPI 
my_CreateProcessW
	(
	LPCWSTR					lpApplicationName,
	LPWSTR					lpCommandLine,
	LPSECURITY_ATTRIBUTES	lpProcessAttributes,
	LPSECURITY_ATTRIBUTES	lpThreadAttributes,
	BOOL					bInheritHandles,
	DWORD					dwCreationFlags,
	LPVOID					lpEnvironment,
	LPCWSTR					lpCurrentDirectory,
	LPSTARTUPINFOW			lpStartupInfo,
	LPPROCESS_INFORMATION	lpProcessInformation
	)

//
// DESCRIPTION:		
//
// ASSUMPTIONS:		User mode
//
// SIDE EFFECTS:
//
// RETURN VALUES:
//
//

{
	TRACE_ENTER ();

NTSTATUS	status;
BOOL		ret_val;

	//
	// Create string descriptors for logging parameters
	//

	UNICODE_STRING	lpApplicationName_us;
	lpApplicationName_us.Buffer = (PWSTR) lpApplicationName;
	lpApplicationName_us.Length = lpApplicationName_us.MaximumLength = (USHORT) wcslen (lpApplicationName) * sizeof (WCHAR);

	UNICODE_STRING	lpCommandLine_us;
	lpCommandLine_us.Buffer = lpCommandLine;
	lpCommandLine_us.Length = lpCommandLine_us.MaximumLength = (USHORT) wcslen (lpCommandLine) * sizeof (WCHAR);

	UNICODE_STRING	lpCurrentDirectory_us;
	lpCurrentDirectory_us.Buffer = (LPWSTR)lpCurrentDirectory;
	lpCurrentDirectory_us.Length = lpCurrentDirectory_us.MaximumLength = (USHORT) wcslen (lpCurrentDirectory) * sizeof (WCHAR);

	DECLARE_UNICODE_STRING (api_name, L"CreateProcessW");

	//
	// Write a pre-call entry to the log
	//

	TraceLoggingWrite (TA_tlg, "DLL-Trace-PRECALL", TraceLoggingOpcode (TL_OPC_TRACE), TraceLoggingLevel (TRACE_LEVEL_INFORMATION),
		TraceLoggingKeyword (TL_KW_TRACE_PRE), 
		TraceLoggingUnicodeString (&api_name, "Calling API"),
		TraceLoggingUnicodeString (&lpApplicationName_us, "lpApplicationName"),
		TraceLoggingUnicodeString (&lpCommandLine_us, "lpCommandLine"),
		TraceLoggingUnicodeString (&lpCurrentDirectory_us, "lpCurrentDirectory")
		);

	//
	// Call the real API
	//

	ret_val = real_CreateProcessW 
			(
			lpApplicationName,
			lpCommandLine,
			lpProcessAttributes,
			lpThreadAttributes,
			bInheritHandles,
			dwCreationFlags,
			lpEnvironment,
			lpCurrentDirectory,
			lpStartupInfo,
			lpProcessInformation
			);

	//
	// Write a post-call entry to the log
	//

	status = GetLastError ();

	TraceLoggingWrite (TA_tlg, "DLL-Trace-POSTCALL", TraceLoggingOpcode (TL_OPC_TRACE), TraceLoggingLevel (TRACE_LEVEL_INFORMATION),
		TraceLoggingKeyword (TL_KW_TRACE_POST), 
		TraceLoggingUnicodeString (&api_name, "Called API"),
		TraceLoggingUInt32 (ret_val, "Return value"),
		TraceLoggingUInt32 (status, "Last error status")
		);

	TRACE_EXIT ();
	return ret_val;
}							// End my_CreateProcessW


